---
layout: post
title:  "Why you should make your code modular (aka Don't Forget Your Intro to Programming Class)"
date:   2016-09-03 8:54:34 -0500
---
I write this post in solidarity for my sisters and brothers who, like me, make a mistake every once in a while (read: every day). 

I was in the process of finishing up a student progress tracking system for one of the business school's academic programs. All code was done, my unit and integration tests were passing with flying colors in the development instance, and the academic program leadership was happy with the result. What more could I ask for? Well I could ask for my tests to fail for unspecified reasons once I pushed to production. I would never ask for that, but that's what I got.

The weird thing about it was that my tests were the only things that were failing. The actual application worked perfectly. Now, at this point, less scrupulous developers might just shun the tests and go home. I, however, have the pleasure of having developed this application on the Salesforce platform. For those who don't know (you blessed souls), when you try to push to production in Salesforce, all unit tests are run automatically (and I mean _all_ tests that exist in the codebase), and if any fail, your deploy is aborted. Having no unit tests also doesn't work, as Salesforce requires 75% code coverage for all production code.

So here I was, 5pm on a Friday looking at a really informative runtime error that said something like:

`You have uncommitted work pending. Please commit or rollback before calling out.`

That's it, no line number, no file, no nothing. The following is everything that I did to fix this that I should have been doing from the get-go.

The method that was causing the error looked something like: 

```java

@future(callout=true)
public static void createCourse(...) {
    <start huge block of callouts>
        <create canvas course>
        <look up student profiles>
        <add all students to course>
        <look up teacher profiles>
        <add teachers to course>
    <end huge block of callouts>
    <do some database updates>
}

```

and the test class:

```java
public static void testCreateCourse() {
    <set up http mocking, some other stuff>
    Test.startTest();
    TrackerController.createCourse(...)
    Test.stopTest();
}
```

A little background: in Apex (Salesforce Java 5 fork that is used for most Salesforce development), the `@future` annotation runs the method asnychronously, out of the context of the rest of the code running. This is important, because you can't do database operations before and after you perform a callout, and this was an unavoidable pattern the way I designed the rest of the code. I figured out that the problem was that when I called `createCourse()` within `Test.startTest()` and `Test.stopTest()`, it was as if the `@future` annotation didn't exist, and the method fired off immediately in the context of the rest of the program. Now this wasn't really my fault, but it was my problem, the tracking system needed to be in production ASAP.

At this point I was thinking I was gonna spend the entire night refactoring the base logic of the program. Fortunately, the face of my intro programming class professor popped into my head and whispered _modularity and reuse_ before fading back out to the nether (this may or may not have actually happened). What I ended up doing wasn't ridiculously complicated, I just turned the above into this:

``java
@future(callout=true)
public static void createCourse(...) {
    createCanvasCourse();
    lookUpProfiles(students);
    addToCourse(students);
    lookUpProfiles(teachers);
    addToCourse(teachers);
    <do some database updates>
}

private static CanvasCourse createCanvasCourse() {
    <return result of callout>
}

private static List<CanvasProfile> lookUpProfiles(List<ID> who) {
    <return result of callout>
}

private static void addToCourse(List<CanvasProfile> who) {
    <return result of callout>
}
```

```java
public static void testCreateCanvasCourse() {
    <set up http mocking, some other stuff>
    Test.startTest();
    TrackerController.createCanvasCourse(...)
    Test.stopTest();
}

public static void testLookUpProfiles() {
    <set up http mocking, some other stuff>
    Test.startTest();
    TrackerController.lookUpProfiles(...)
    Test.stopTest();
}

public static void testAddToCourse() {
    <set up http mocking, some other stuff>
    Test.startTest();
    TrackerController.addToCourse(...)
    Test.stopTest();
}
```

I just factored out the meat of `createCourse()` into 3 separate methods that I could all call separately outside of the context of this future method. That's it. I've been programming for how many years and this thing I learned on the 2nd day of class my sophomore year of high school fixed this seemingly complex problem.

So what, ultimately, did I learn from this experience? The advice you get in your Intro to Programming class still applies even when you think you're past the point of having to think about the basics like that. It also taught me a bit of humility, as I debate whether to even post this because it shouldn't have even been an issue in the first place. 

Until next time,

Nick

